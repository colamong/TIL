---
layout: post
title: "Dynamic Programming(동적 계획법)"
date: 2025-04-05 21:01:52 +0900
categories: [Algorithm/DP Algorithm/recursive Algorithm/memoization]
---

## 😉코드 미리 보기

- 피보나치 수열 with 재귀

```java
int fibo(n){
    if(n<2) return n;
    else return fibo(n-1) + fibo(n-2);
}
```

- 피보나치 수열 with 재귀 & 메모이제이션

```java
int memo = new long[N+1];
Arrays.fill(memo, -1);
memo[0] = 0; memo[1] = 1;
int fibo_m(n){
    if(n>=2 && memo[n] == -1) //메모가 없다면 메모 생성
        memo[n] = fibo_m(n-1) + fibo_m(n-2);
    return memo[n]; //메모가 되어있다면 메모 리턴
}
```

- 피보나치 수열 with DP

```java
int[] f = new f[n+1];
int fibo_dp(int n) {
    f[0] = 0;
    f[1] = 1;
    for(int i = 2; i<=n; i++) {
        f[i] = f[i-1] + f[i-2];
    }
    return f[n];
}
```

## 📚이론

## 재귀 호출과 메모이제이션

### **피보나치 수열**

- 0항과 1항으로 시작하고 이전 두 수의 합을 다음 항으로 하는 수열
- ex) i번째 값을 계산하는 함수 F
  - F0 = 0 F1 = 1
  - Fi = F(i-1) + F(i-2) when i ≥ 2
- **재귀 함수**로 구현이 가능

```java
fibo(n){
    if(n<2) return n;
    else return fibo(n-1) + fibo(n-2);
}
```

문제점 존재 → 다수의 중복 호출

- 설계 시 Call Tree로 확인 가능
  ![image.png](/_posts/img/250405img.png)
  중복이 다수 발생!
  어떻게 중복을 피할 수 있을까? but 완전히 새로운 것을 생각하는 건 쉽지 않음
  → **메모이제이션!**

### **메모이제이션** - **동적 계획법에 핵심!**

- 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해 매번 다시 계산하지 않도록 하는 기술 → 전체적인 실행 속도 증가
  - 캐싱과 유사

<aside>
💡

메모리와 연산 시간의 관계
연산 시간과 메모리는 보통 **트레이드 오프** **관계**를 가진다.
**중복 호출의 정도**에 따라 시간 복잡도와 공간 복잡도를 모두 고려해
적절히 균형을 맞추는게 좋다. → **상태 공간 트리 (Call Tree) 꼭 만들어봐라**

</aside>

- 메모이제이션은 순수함수(멱등성이 보장)에서만 사용 가능!
  - 순수함수 : 같은 값을 넣으면 항상 같은 결과가 나오는 함수
- 메모이제이션 적용 예시

```java
int memo = new long[N+1];
Arrays.fill(memo, -1);
memo[0] = 0; memo[1] = 1;
fibom(n){
    if(n>=2 && memo[n] == -1) //메모가 없다면 메모 생성
        memo[n] = fibom(n-1) + fibom(n-2);
    return memo[n]; //메모가 되어있다면 메모 리턴
}
```

메모를 만들 때 함수에서 **절대 나올 수 없는 값으로 초기화**가 필요!

## 동적 계획법 = DP

### 동적 계획법

- 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘 설계 기법
  1. 먼저 작은 부분 문제들의 최적해를 구한다.
  2. 이들을 이용하여 보다 큰 크기의 부분 문제들을 해결한다. (순환적으로)
     1. 점화식으로 표현 가능
  3. 최종적으로 원래 주어진 문제를 해결한다.
- 동적 계획법의 **필수 요건**
  - 중복 부분문제 구조
    - 중복된 부분문제를 지속적으로 사용하는가? → 연산 감소량 증가!
    - 각각의 문제의 해를 따로 저장하여 여러번 연산하는 것을 방지
  - 최적 부분문제 구조
    - 어떤 **문제에 대한 해**가 **최적**일 때 그 해를 구성하는 **작은 문제들의 해** 역시 **최적**이어야한다!
    - 작은 문제들의 최적해로 큰 문제의 최적해를 구하는 방식이기에 작은 문제들이 최적해로 구성되지 않는다면 DP로 풀 수 없음!
      - ex) 최장 경로 문제 - 최적 원칙이 적용되지 않음
        - AtoB의 최장은 A→C→B / AtoC의 최장은 A→B→C / AtoD의 최장은 A→C→B→D
        - 이때 A→C는 AtoC의 최장이 아님 → 최적해 X →분할 불가능 = DP로는 해결 불가능

### 분할 정복 vs 동적 계획법

- 분할 정복 - 하향식 방법으로 접근
  - 연관 없는 부분 문제로 분할
  - 부분 문제를 재귀적으로 해결
  - 부분 문제의 해를 결합
  - ex) 병합 정렬, 퀵 정렬
- DP -상향식 방법으로 접근
  - 부분 문제들의 연관성이 필수! → 의존적 관계 존재 (문제에 따라 관계가 다름)
  - 부분 문제들이 더 작은 부분 문제를 공유
  - 모든 부분 문제를 한번만 계산하고 저장해 재사용

### DP 적용 접근 방법

- 3단계

1. 최적해 구조의 특성을 파악
   - 문제를 **부분 문제로 나눔**
2. 최적해의 값을 재귀적으로 정의 = **점화식 정의**
   - 부분 문제의 최적해 값에 기반하여 문제의 최적해 값을 정의
3. **상향식 방법**으로 최적해의 값을 계산
   - 가장 작은 부분 문제부터 해를 구한 뒤 **테이블에 저장**
   - 부분 문제의 해를 이용해 점차적로 상위 부분 문제의 최적해를 구함(상향식 방법)

- 더 자세한 풀이 순서
  1. 문제에 대한 이해 &정의
     - 최적해 or 경우의 수
  2. 부분 문제 식별
  3. 동적 테이블 정의 (부분문제에 대한 상태 정의)
     - 상태를 표현 가능한 자료구조 설계 (D)
     - 1차원, 2차원, ….
     - D[i] = 값
       - i : 부분 문제의 상태
       - D[i] : 부분문제를 해결한 값 →저장
  4. 부분 문제들의 관게를 파악 후 **점화식 도출**
     - D[i], D[i-1], D[i-2]… 이들의 관계는?
       - 관계를 점화식으로 표현
       - 관계가 수립 안되는 경우 파악 = 기저 상황
  5. 동적 테이블 초기화 및 부분 문제의 해 계산
     - 기저 상황 상태 초기화
     - 점화식을 이용한 테이블 채우기
  6. 해 도출
  7. (Optional) 공간복잡도 최적화
- DP가 어렵다면?
  1. 하향식 접근으로 설계
  2. 상태 공간 트리 작성 - 중복 호출 파악
  3. 기저부터 상향식으로 뒤집어서 생각

ex) 피보나치 수열 with DP

```java
int[] f = new f[n+1];
fibo_dp(int n) {
    f[0] = 0;
    f[1] = 1;
    for(int i = 2; i<=n; i++) {
        f[i] = f[i-1] + f[i-2];
    }
    return f[n];
}
```

재귀와 달리 중복 계산X / 반복문 사용으로 함수 호출 발생 X

계산 횟수 = n+1 (0~n까지 한번씩만 계산)
